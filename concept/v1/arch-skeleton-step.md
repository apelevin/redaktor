# Архитектура третьего шага: генерация скелета и уточняющие вопросы

## Обзор

Третий шаг пайплайна создания юридического документа отвечает за:
1. **Генерацию структуры документа (скелета)** на основе сгенерированного контекста
2. **Выбор пользователем пунктов** из скелета для включения в документ
3. **Подтверждение структуры** и переход к режиму уточняющих вопросов
4. **Задавание уточняющих вопросов** по каждому выбранному пункту скелета для получения детальной информации
5. **Переход к генерации текста документа** после ответа на все вопросы

## Архитектура компонентов

### 1. Frontend: Step3Panel.tsx

**Расположение:** `app/components/Step3Panel.tsx`

**Ответственность:**
- Отображение интерфейса для генерации скелета
- Отображение сгенерированного скелета с возможностью выбора пунктов
- Управление выбором пунктов (выбрать все, снять все, по разделам)
- Подтверждение структуры
- Переключение между режимами: выбор пунктов → уточняющие вопросы

**Ключевые состояния:**
- `isGenerating: boolean` — идет ли генерация скелета
- `error: string | null` — ошибки генерации

**Два режима отображения:**

#### Режим 1: Генерация и выбор пунктов

Отображается когда `skeletonConfirmed === false`:

1. **Кнопка генерации скелета:**
   - "Сгенерировать структуру документа"
   - Вызывает `handleGenerateSkeleton()`
   - Отправляет запрос к `/api/pipeline/skeleton`

2. **Отображение скелета:**
   - Разделы с заголовками
   - Пункты с чекбоксами для выбора
   - Кнопки "Выбрать все" / "Снять все" для всего скелета
   - Кнопки "Выбрать все" / "Снять все" для каждого раздела
   - Кнопка "Регенерировать" для повторной генерации

3. **Кнопка подтверждения:**
   - "Подтвердить структуру (N пунктов выбрано)"
   - Видна только когда выбрано хотя бы один пункт
   - Вызывает `handleConfirmSkeleton()`

#### Режим 2: Двухпанельный layout (после подтверждения)

Отображается когда `skeletonConfirmed === true`:

- **Левая панель (50% ширины):**
  - Отображение скелета в режиме только для чтения
  - Выделение текущего обрабатываемого пункта (синий фон)
  - Выделение выбранных пунктов (зеленый фон)
  - Невыбранные пункты затемнены

- **Правая панель (50% ширины):**
  - Компонент `SkeletonChatPanel` для уточняющих вопросов

**Данные из store:**
- `documentType` — тип документа
- `generatedContext` — полное описание договора (из шага 2)
- `skeleton` — структура документа (разделы и пункты)
- `selectedSkeletonItems` — Set выбранных пунктов (ключ: `sectionId-itemIndex`)
- `skeletonConfirmed` — флаг подтверждения структуры
- `currentSkeletonItem` — текущий пункт, по которому задается вопрос

**Основные функции:**

#### `handleGenerateSkeleton()`
1. Валидирует наличие `documentType` и `generatedContext`
2. Отправляет POST запрос к `/api/pipeline/skeleton`
3. Сохраняет результат через `setSkeleton()`
4. Отслеживает затраты через `addCostRecord()`

#### `handleConfirmSkeleton()`
1. Проверяет, что выбран хотя бы один пункт
2. Вызывает `confirmSkeleton()` для установки флага `skeletonConfirmed = true`
3. Переключает UI на двухпанельный режим

### 2. Frontend: SkeletonChatPanel.tsx

**Расположение:** `app/components/SkeletonChatPanel.tsx`

**Ответственность:**
- Последовательная обработка выбранных пунктов скелета
- Задавание уточняющих вопросов по каждому пункту
- Автоматический пропуск пунктов, не требующих вопросов
- Отображение истории вопросов и ответов
- Управление переходом к шагу 4

**Ключевые состояния:**
- `messages: ChatMessage[]` — история сообщений (вопросы и ответы)
- `currentQuestion: Question | null` — текущий активный вопрос
- `isLoading: boolean` — идет ли загрузка/обработка
- `currentItemIndex: number` — индекс текущего обрабатываемого пункта
- `processedItems: Set<string>` — Set обработанных пунктов
- `processingItemKey: string | null` — ключ пункта, который сейчас обрабатывается
- `allItemsProcessed: boolean` — все ли пункты обработаны

**Основные функции:**

#### `processNextItem()`
Рекурсивная функция для последовательной обработки пунктов:

1. **Проверка завершения:**
   - Если `currentItemIndex >= selectedItems.length` → все обработано
   - Устанавливает `allItemsProcessed = true`

2. **Проверка уже обработанных:**
   - Если пункт уже в `processedItems` → пропуск, переход к следующему

3. **Защита от повторных вызовов:**
   - Если `processingItemKey === itemKey` → уже обрабатывается, выход

4. **Установка текущего пункта:**
   - `setCurrentSkeletonItem()` — для отображения в левой панели
   - `setProcessingItemKey()` — флаг обработки

5. **Запрос вопроса:**
   - POST запрос к `/api/pipeline/skeleton-item-question`
   - Передает: `document_type`, `generated_context`, `section_title`, `section_id`, `item_text`, `item_index`, `existing_answers`

6. **Обработка ответа:**
   - Если `data.question` существует:
     - Проверка на дубликаты (по ID и тексту)
     - Добавление вопроса в `messages`
     - Установка как текущего вопроса
   - Если `data.question === null`:
     - Пункт не требует вопроса → тихо пропускается
     - `markItemAsProcessed()`
     - Переход к следующему пункту

7. **Обработка ошибок:**
   - Пункт помечается как обработанный
   - Переход к следующему пункту

#### `handleAnswerSubmit()`
Обработка ответа пользователя на вопрос:

1. **Сохранение ответа:**
   - `addSkeletonItemAnswer()` — сохраняет ответ в store
   - Форматирование ответа для отображения в чате
   - Добавление в `messages`

2. **Пометка пункта как обработанного:**
   - `markItemAsProcessed()`

3. **Переход к следующему пункту:**
   - Очистка текущего вопроса
   - Увеличение `currentItemIndex`
   - Проверка: если это последний пункт → `allItemsProcessed = true`

#### `markItemAsProcessed()`
Добавляет ключ пункта в `processedItems` Set.

**useEffect хуки:**

1. **Проверка завершения обработки:**
   ```typescript
   useEffect(() => {
     // Проверяет, все ли выбранные пункты обработаны
     // Устанавливает allItemsProcessed = true
   }, [processedItems.size, selectedItems.length, ...])
   ```

2. **Автоматическая обработка следующего пункта:**
   ```typescript
   useEffect(() => {
     // Если есть необработанные пункты и нет текущего вопроса
     // Вызывает processNextItem()
   }, [currentItemIndex, isLoading, currentQuestion, ...])
   ```

**Особенности:**

- **Автоматический пропуск:** Пункты, не требующие вопросов, пропускаются без отображения сообщений
- **Защита от дубликатов:** Проверка вопросов по ID и тексту (первые 50 символов)
- **Визуальная индикация:** Отображение текущего пункта в левой панели
- **Прогресс:** Отображение "Пункт X из Y" в заголовке

### 3. API Endpoint: /api/pipeline/skeleton

**Расположение:** `app/api/pipeline/skeleton/route.ts`

**Метод:** POST

**Входные параметры:**
```typescript
{
  document_type: string;           // Тип документа
  generated_context: string;       // Полное описание договора (из шага 2)
  qa_context?: Array<{...}>;      // История вопросов/ответов (опционально, если нет generated_context)
  jurisdiction?: string;           // Юрисдикция (опционально)
  style?: string;                  // Стиль документа (опционально)
}
```

**Выходные данные:**
```typescript
{
  skeleton: Section[];             // Структура документа
  usage?: TokenUsage;              // Использование токенов
  model?: string;                  // Использованная модель
}
```

**Логика:**
1. Валидирует обязательные параметры
2. Приоритет: `generated_context` > `qa_context`
3. Вызывает `generateSkeleton()` из `lib/openai/skeleton-generator.ts`
4. Возвращает результат с отслеживанием затрат

### 4. API Endpoint: /api/pipeline/skeleton-item-question

**Расположение:** `app/api/pipeline/skeleton-item-question/route.ts`

**Метод:** POST

**Входные параметры:**
```typescript
{
  document_type: string;           // Тип документа
  generated_context: string;       // Полное описание договора
  section_title: string;          // Название раздела
  section_id: string;              // ID раздела
  item_text: string;              // Текст пункта из скелета
  item_index: number;              // Индекс пункта в разделе
  existing_answers: Record<string, any>; // Уже собранные ответы по другим пунктам
}
```

**Выходные данные:**
```typescript
{
  question: Question | null;       // Вопрос или null, если не нужен
  reason?: string;                 // Объяснение, почему вопрос нужен/не нужен
  usage?: TokenUsage;              // Использование токенов
  model?: string;                  // Использованная модель
}
```

**Логика:**
1. Валидирует обязательные параметры
2. Вызывает `generateSkeletonItemQuestion()` из `lib/openai/skeleton-item-question-generator.ts`
3. Возвращает результат с отслеживанием затрат

### 5. Skeleton Generator: lib/openai/skeleton-generator.ts

**Расположение:** `lib/openai/skeleton-generator.ts`

**Ответственность:**
- Формирование промпта для генерации структуры документа
- Вызов OpenAI API для генерации скелета
- Валидация структуры ответа
- Возврат скелета в формате `Section[]`

**Основная функция:**

#### `generateSkeleton(params: SkeletonGenerationParams)`

**Процесс:**

1. **Выбор источника контекста:**
   - Приоритет: `generatedContext` > `qa_context`
   - Если есть `generatedContext` → используется как есть
   - Если нет → форматируется `qa_context` в текст

2. **Загрузка и рендеринг промпта:**
   - Загружает промпт из `prompts/skeleton-generation.md`
   - Подставляет переменные:
     - `document_type`
     - `jurisdiction` (если указана)
     - `style` (если указан)
     - `context` (отформатированный)
     - `has_generated_context` ('true' или 'false')

3. **Вызов OpenAI API:**
   - Использует модель из конфигурации `skeleton_generation`
   - System message: инструкция для юридического эксперта
   - User message: сформированный промпт
   - `response_format: { type: 'json_object' }` — возвращает JSON

4. **Валидация ответа:**
   - Проверяет наличие `sections` массива
   - Валидирует структуру каждой секции:
     - `id` (string)
     - `title` (string)
     - `items` (array of strings)

5. **Обработка ответа:**
   - Парсит JSON
   - Возвращает `sections` как `Section[]`
   - Обрабатывает использование токенов

### 6. Skeleton Item Question Generator: lib/openai/skeleton-item-question-generator.ts

**Расположение:** `lib/openai/skeleton-item-question-generator.ts`

**Ответственность:**
- Определение необходимости вопроса для пункта скелета
- Генерация уточняющего вопроса, если нужен
- Форматирование существующих ответов для контекста
- Возврат вопроса или `null`

**Основная функция:**

#### `generateSkeletonItemQuestion(params: SkeletonItemQuestionParams)`

**Процесс:**

1. **Форматирование существующих ответов:**
   - Преобразует `existing_answers` (Record<string, any>) в читаемый текст
   - Формат: `Пункт sectionId-itemIndex:\n  [Вопрос: questionId]\n  Ответ: {answer}`
   - Если ответов нет → "Ответов пока нет."

2. **Загрузка и рендеринг промпта:**
   - Загружает промпт из `prompts/skeleton-item-question.md`
   - Подставляет переменные:
     - `document_type`
     - `generated_context`
     - `section_title`
     - `item_text`
     - `existing_answers` (отформатированные)

3. **Вызов OpenAI API:**
   - Использует модель из конфигурации `question_generation`
   - System message: инструкция для ассистента
   - User message: сформированный промпт
   - `response_format: { type: 'json_object' }` — возвращает JSON

4. **Обработка ответа:**
   - Парсит JSON
   - Если `question === null` → возвращает `{ question: null, reason }`
   - Если `question` существует:
     - Валидирует структуру Question
     - Проверяет связь ID с пунктом скелета
     - Если ID не связан → генерирует новый: `${document_type}.skeleton.${section_id}.${item_index}`
     - Возвращает вопрос с usage и моделью

### 7. Промпт: prompts/skeleton-generation.md

**Расположение:** `prompts/skeleton-generation.md`

**Ключевые принципы:**

1. **Контекст не ограничивает структуру:**
   - Контекст отражает только часть договора
   - Служит подсказкой для адаптации, не ограничивает состав разделов
   - Все стандартные разделы должны присутствовать

2. **Логика формирования:**
   - Шаг 1: Определить набор стандартных разделов
   - Шаг 2: Адаптировать разделы под контекст
   - Шаг 3: Обеспечить юридическую последовательность
   - Шаг 4: Сформировать точки будущего наполнения

3. **Правила взаимоотношения контекста и структуры:**
   - Контекст — модификатор, не ограничитель
   - Контекст — источник вариативности
   - Разделы не исключаются только потому, что про них не спрашивали

4. **Формат выходных данных:**
   ```json
   {
     "sections": [
       {
         "id": "string",
         "title": "string",
         "items": ["string"]
       }
     ]
   }
   ```

### 8. Промпт: prompts/skeleton-item-question.md

**Расположение:** `prompts/skeleton-item-question.md`

**Ключевые принципы:**

1. **Вопрос НЕ нужен, если:**
   - Вся информация есть в `generated_context`
   - Информация уже собрана в `existing_answers`
   - Пункт стандартный и не требует уточнений
   - Информация может быть взята из общих норм права

2. **Вопрос НУЖЕН, если:**
   - Для точной формулировки требуется дополнительная информация
   - Пункт касается конкретных параметров, которых нет в контексте
   - Нужны детали, влияющие на юридическую формулировку

3. **Критически важно — предотвращение дубликатов:**
   - Внимательно изучать `existing_answers`
   - Не задавать вопрос, если похожий уже был задан
   - Правило: один аспект = один вопрос

4. **Один пункт = один вопрос:**
   - Для каждого пункта генерируется ТОЛЬКО ОДИН вопрос
   - Если нужно собрать несколько аспектов, объединить в один комплексный вопрос

5. **Формат ответа:**
   - Если вопрос не нужен: `{ "question": null, "reason": "..." }`
   - Если вопрос нужен: `{ "question": {...Question...}, "reason": "..." }`

### 9. State Management: lib/store/document-store.ts

**Ключевые поля для шага 3:**

```typescript
generatedContext: string | null;              // Описание договора (шаг 2)
skeleton: Section[] | null;                   // Структура документа
selectedSkeletonItems: Set<string>;          // Выбранные пункты
skeletonConfirmed: boolean;                   // Флаг подтверждения
currentSkeletonItem: { sectionId: string; itemIndex: number } | null;
skeletonItemAnswers: Record<string, any>;     // Ответы по пунктам
```

**Ключевые действия:**

- `setSkeleton(skeleton)` — сохраняет сгенерированный скелет
- `toggleSkeletonItem(sectionId, itemIndex)` — переключает выбор пункта
- `selectAllSkeletonItems(sectionId?)` — выбирает все пункты (в разделе или во всем скелете)
- `deselectAllSkeletonItems(sectionId?)` — снимает выбор со всех пунктов
- `confirmSkeleton()` — устанавливает `skeletonConfirmed = true`
- `setCurrentSkeletonItem(item)` — устанавливает текущий пункт
- `addSkeletonItemAnswer(sectionId, itemIndex, answer)` — сохраняет ответ по пункту

## Поток данных

### Последовательность операций

1. **Генерация скелета:**
   ```
   Step3Panel: handleGenerateSkeleton()
   ↓
   POST /api/pipeline/skeleton
   ↓
   generateSkeleton()
   ↓
   Форматирование контекста → Загрузка промпта → OpenAI API
   ↓
   Валидация структуры
   ↓
   setSkeleton(skeleton)
   ```

2. **Выбор пунктов:**
   ```
   Пользователь выбирает пункты через чекбоксы
   ↓
   toggleSkeletonItem() / selectAllSkeletonItems() / deselectAllSkeletonItems()
   ↓
   selectedSkeletonItems обновляется
   ```

3. **Подтверждение структуры:**
   ```
   Пользователь нажимает "Подтвердить структуру"
   ↓
   handleConfirmSkeleton()
   ↓
   confirmSkeleton()
   ↓
   skeletonConfirmed = true
   ↓
   UI переключается на двухпанельный режим
   ↓
   SkeletonChatPanel начинает обработку
   ```

4. **Обработка пунктов:**
   ```
   SkeletonChatPanel: useEffect → processNextItem()
   ↓
   POST /api/pipeline/skeleton-item-question
   ↓
   generateSkeletonItemQuestion()
   ↓
   Форматирование existing_answers → Загрузка промпта → OpenAI API
   ↓
   Если question === null:
   ├─ Пропуск пункта (тихо)
   ├─ markItemAsProcessed()
   └─ Переход к следующему пункту
   ↓
   Если question существует:
   ├─ Проверка на дубликаты
   ├─ Добавление в messages
   ├─ Установка как currentQuestion
   └─ Ожидание ответа пользователя
   ```

5. **Обработка ответа:**
   ```
   Пользователь отвечает на вопрос
   ↓
   handleAnswerSubmit()
   ↓
   addSkeletonItemAnswer() → сохранение в store
   ↓
   markItemAsProcessed()
   ↓
   Переход к следующему пункту (currentItemIndex++)
   ↓
   useEffect → processNextItem() (следующий пункт)
   ```

6. **Завершение обработки:**
   ```
   Все пункты обработаны
   ↓
   allItemsProcessed = true
   ↓
   Кнопка "Перейти к генерации текста документа" активируется
   ↓
   onAllItemsProcessed()
   ↓
   setCurrentStep('step4')
   ```

### Формат ключей

- **Выбранные пункты:** `sectionId-itemIndex` (например, `"section-1-0"`)
- **Ответы пользователя:** `sectionId-itemIndex` → объект с `questionId`, `raw`, `selectedOptionIds`
- **Обработанные пункты:** `sectionId-itemIndex` в Set `processedItems`

## Особенности реализации

### Автоматический пропуск пунктов

Пункты, не требующие вопросов, пропускаются **тихо**, без отображения сообщений в чате. Это обеспечивает:
- **Чистый интерфейс** — пользователь видит только релевантные вопросы
- **Быстрое прохождение** — не нужно ждать обработки очевидных пунктов
- **Фокус на важном** — внимание на пунктах, требующих уточнений

### Защита от дубликатов

Многоуровневая защита от дублирования вопросов:

1. **На уровне промпта:**
   - Инструкции LLM внимательно проверять `existing_answers`
   - Правило: один аспект = один вопрос

2. **На уровне генератора:**
   - Форматирование `existing_answers` с указанием вопросов и ответов
   - Передача полного контекста в промпт

3. **На уровне UI:**
   - Проверка вопросов по ID
   - Проверка по тексту (первые 50 символов)
   - Пропуск дубликатов при добавлении в `messages`

### Последовательная обработка

Обработка пунктов происходит **последовательно**, один за другим:
- **Согласованность** — каждый следующий вопрос учитывает предыдущие ответы
- **Контроль** — можно отслеживать прогресс
- **Простота** — нет сложной логики параллельной обработки

### Визуальная индикация

- **Текущий пункт:** Выделяется синим фоном в левой панели
- **Выбранные пункты:** Выделяются зеленым фоном
- **Невыбранные пункты:** Затемнены
- **Прогресс:** Отображение "Пункт X из Y" в заголовке чата

### Отслеживание затрат

Каждый вызов API отслеживается через `addCostRecord()`:
- Модель
- Использование токенов
- Операция: `'skeleton'` или `'question_generation'`
- Временная метка
- Стоимость

## Пример использования

### Входные данные

**Сгенерированный контекст (из шага 2):**
```
Договор купли-продажи автомобиля между физическими лицами.
Продавец: физическое лицо.
Покупатель: физическое лицо.
Автомобиль: Range Rover 2020 года, VIN: 534-848-38.
Цена: 4 миллиона рублей.
Оплата: наличный расчет при передаче.
Дата передачи: 1 января 2026 года.
Место передачи: Москва, улица Ленина, дом 34.
```

### Процесс генерации скелета

1. **Запрос к API:**
   ```json
   {
     "document_type": "car_sale_contract",
     "generated_context": "..."
   }
   ```

2. **Ответ API:**
   ```json
   {
     "skeleton": [
       {
         "id": "parties",
         "title": "Стороны договора",
         "items": [
           "Данные продавца",
           "Данные покупателя"
         ]
       },
       {
         "id": "subject",
         "title": "Предмет договора",
         "items": [
           "Описание автомобиля",
           "Права и обязанности сторон"
         ]
       },
       {
         "id": "price",
         "title": "Цена и порядок расчетов",
         "items": [
           "Цена договора",
           "Способ оплаты"
         ]
       }
       // ... другие разделы
     ]
   }
   ```

### Процесс выбора и подтверждения

1. **Пользователь выбирает пункты:**
   - Выбирает "Данные продавца", "Данные покупателя"
   - Выбирает "Описание автомобиля"
   - Выбирает "Цена договора", "Способ оплаты"
   - И т.д.

2. **Подтверждение:**
   - Нажимает "Подтвердить структуру (8 пунктов выбрано)"
   - `skeletonConfirmed = true`
   - UI переключается на двухпанельный режим

### Процесс уточняющих вопросов

1. **Пункт 1: "Данные продавца"**
   - API возвращает вопрос: "Укажите полное ФИО продавца"
   - Пользователь отвечает: "Иванов Иван Иванович"
   - Ответ сохраняется в `skeletonItemAnswers["parties-0"]`

2. **Пункт 2: "Данные покупателя"**
   - API возвращает вопрос: "Укажите полное ФИО покупателя"
   - Пользователь отвечает: "Петров Петр Петрович"
   - Ответ сохраняется

3. **Пункт 3: "Описание автомобиля"**
   - API возвращает `question: null` (вся информация есть в контексте)
   - Пункт пропускается тихо
   - Переход к следующему пункту

4. **Пункт 4: "Цена договора"**
   - API возвращает `question: null` (цена указана в контексте)
   - Пункт пропускается

5. **Пункт 5: "Способ оплаты"**
   - API возвращает `question: null` (способ указан в контексте)
   - Пункт пропускается

6. **И так далее...**

### Завершение

- Все пункты обработаны
- `allItemsProcessed = true`
- Кнопка "Перейти к генерации текста документа" активируется
- Переход на шаг 4

## Обработка ошибок

- **Ошибка генерации скелета:** Отображается в UI, пользователь может повторить попытку
- **Ошибка генерации вопроса:** Пункт помечается как обработанный, переход к следующему
- **Пустой ответ API:** Обрабатывается как отсутствие вопроса
- **Неверная структура скелета:** Валидация на уровне генератора, возврат ошибки

## Производительность

- **Задержка между пунктами:** 50ms при пропуске (для плавности UI)
- **Последовательная обработка:** Один пункт за раз (для согласованности)
- **Кэширование:** Результаты сохраняются в store, повторная обработка не требуется

## Расширяемость

Архитектура позволяет легко:
- Добавить поддержку новых типов документов
- Изменить модель генерации через конфигурацию
- Добавить дополнительные параметры в промпты
- Реализовать параллельную обработку (если потребуется)
- Добавить валидацию сгенерированного скелета
- Добавить возможность редактирования скелета перед подтверждением

