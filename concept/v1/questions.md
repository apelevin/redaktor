Вот целиковое описание концепции **“вопроса”** для право(редактор), которое можно вставить в Cursor как техническую спецификацию.

---

## Концепция вопроса в право(редактор)

В право(редактор) вопрос — это **универсальная единица диалога**, через которую мы собираем параметры будущего юридического документа. Один и тот же параметр может быть собран:

* открытым текстовым ответом,
* выбором одного варианта,
* выбором нескольких вариантов.

Вопрос всегда существует **в связке с типом документа** и **конкретными полями контекста**, которые он заполняет.

---

## Две оси вопроса: UI и тип данных

У вопроса есть две независимые характеристики:

1. **Формат UI (`uiKind`)** — то, как вопрос отображается пользователю:

   * `open` — открытый текстовый ответ;
   * `single` — выбор одного варианта из списка (radio);
   * `multi` — выбор нескольких вариантов (checkboxes).

   Опционально можно расширить:

   * `single_with_other` / `multi_with_other` — выбор из списка + поле “Другое”, но для простоты это можно выразить флагом `allowOther`.

2. **Тип данных (`valueType`)** — то, какие данные мы хотим получить на выходе:

   * `string` — произвольная строка;
   * `number` — число;
   * `boolean` — да/нет;
   * `enum` — одно значение из списка;
   * `enum[]` — несколько значений из списка;
   * `date` — дата;
   * `money` — деньги (сумма + валюта) и т.п.

Благодаря этому одну и ту же бизнес-сущность можно сначала уточнить открытым вопросом, потом “зажать” в выбор из нескольких типовых вариантов.

---

## Структура вопроса (модель данных)

```ts
type QuestionUiKind = 'open' | 'single' | 'multi';

type ValueType =
  | 'string'
  | 'number'
  | 'boolean'
  | 'enum'
  | 'enum[]'
  | 'date'
  | 'money';

interface QuestionOption {
  id: string;           // стабильный ID для логики и хранения
  label: string;        // текст в UI
  value: string;        // машинно-читаемое значение
  description?: string; // подсказка для пользователя (необязательно)
}

interface Question {
  id: string;                // уникальный ID вопроса
  documentType: string;      // тип документа (service_contract, nda и т.д.)

  text: string;              // формулировка вопроса для пользователя
  uiKind: QuestionUiKind;    // open | single | multi
  valueType: ValueType;      // enum, enum[], string и т.д.

  isRequired: boolean;       // обязателен ли вопрос для генерации документа

  options?: QuestionOption[]; // варианты ответа (для single/multi)
  allowOther?: boolean;       // можно ли дописать свой вариант (поле "Другое")

  // Зависимости: какие другие поля/вопросы должны быть уже заполнены,
  // чтобы этот вопрос стал "активным" и мог быть задан.
  dependsOn?: string[];      // например: ['parties.executor.type']

  // На какие поля контекста влияет этот ответ.
  // Путь в JSON-контексте документа (dot-notation).
  affects: string[];         // например ['payment.model']

  // Необязательный приоритет/порядок внутри дерева вопросов,
  // используется как дефолтный порядок, если не вмешивается LLM.
  order?: number;
}
```

---

## Структура ответа на вопрос

Ответ хранится в двух слоях:

1. **Сырые данные от пользователя** (то, что он реально ввёл/выбрал).
2. **Нормализованные данные** (то, как это попадает в контекст документа).

```ts
type RawAnswer = string | string[]; // текст или список текстов (для multi)

interface NormalizedAnswer {
  // Структура под нужные поля контекста.
  // Ключи и вложенность соответствуют путям из Question.affects.
  [key: string]: any;
}

interface QuestionAnswer {
  questionId: string;

  raw: RawAnswer;                // сырой ответ пользователя

  // Для single/multi – какие опции были выбраны по ID.
  // Для open-ответов может быть пусто.
  selectedOptionIds?: string[];

  // Нормализованный ответ в структуру контекста документа.
  normalized: NormalizedAnswer;
}
```

Примеры:

* `open`:

  * `raw`: `"Мы хотим заключить договор на год, с автопродлением, если никто не возражает"`
  * `selectedOptionIds`: `[]`
* `single`:

  * `raw`: `"Юридическое лицо (ООО, АО и т.п.)"`
  * `selectedOptionIds`: `["legal_entity"]`
* `multi`:

  * `raw`: `["Разработка ПО", "настройка интеграций маркетинга"]`
  * `selectedOptionIds`: `["dev"]` (остальное пошло через “Другое”)

---

## Поведение разных видов вопросов

### `uiKind: 'open'`

* Показываем одно текстовое поле.
* Пользователь описывает всё свободным текстом.
* LLM-нормализатор разбирает текст, вытаскивает нужные значения и заполняет поля из `affects`.

Используется для:

* сложных параметров (“Опишите порядок оплаты, как вы его видите”),
* случаев, когда ещё неизвестен набор вариантов.

### `uiKind: 'single'`

* Показываем список с одиночным выбором (радиокнопки).
* Пользователь выбирает один вариант.
* Если `allowOther = true`, дополнительно даём поле “Другое”.

Результат:

* `selectedOptionIds` содержит 1 id.
* LLM может использовать `options` и “другое”, чтобы собрать структурный ответ.

Используется для:

* выбора типа стороны,
* выбора модели оплаты,
* выбора применимого права и т.д.

### `uiKind: 'multi'`

* Показываем чекбоксы с множественным выбором.
* Пользователь выбирает несколько вариантов.
* Если `allowOther = true`, даём возможность добавить свой вариант.

Результат:

* `selectedOptionIds` содержит массив id.
* `raw` может содержать и “свои” строки.

Используется для:

* перечисления видов услуг,
* перечисления случаев ответственности,
* перечисления способов защиты интересов и т.п.

---

## Примеры реальных вопросов

### 1. Кто будет исполнителем по договору? (single)

```json
{
  "id": "service_contract.party.executor_type",
  "documentType": "service_contract",
  "text": "Кто будет исполнителем по договору?",
  "uiKind": "single",
  "valueType": "enum",
  "isRequired": true,
  "options": [
    {
      "id": "legal_entity",
      "label": "Юридическое лицо (ООО, АО и т.п.)",
      "value": "legal_entity"
    },
    {
      "id": "sole_entrepreneur",
      "label": "Индивидуальный предприниматель (ИП)",
      "value": "sole_entrepreneur"
    },
    {
      "id": "individual",
      "label": "Физическое лицо",
      "value": "individual"
    }
  ],
  "allowOther": false,
  "affects": ["parties.executor.type"]
}
```

### 2. Какие типы услуг будут оказываться? (multi)

```json
{
  "id": "service_contract.subject.service_types",
  "documentType": "service_contract",
  "text": "Какие типы услуг будут оказываться? Можно выбрать несколько вариантов.",
  "uiKind": "multi",
  "valueType": "enum[]",
  "isRequired": true,
  "options": [
    { "id": "dev", "label": "Разработка ПО", "value": "dev" },
    { "id": "support", "label": "Техническая поддержка", "value": "support" },
    { "id": "consulting", "label": "Консалтинг", "value": "consulting" }
  ],
  "allowOther": true,
  "affects": ["subject.serviceTypes"]
}
```

Пример сохранённого ответа:

```json
{
  "questionId": "service_contract.subject.service_types",
  "raw": ["Разработка ПО", "настройка маркетинговых интеграций"],
  "selectedOptionIds": ["dev"],
  "normalized": {
    "subject": {
      "serviceTypes": ["dev", "custom:marketing_integrations"]
    }
  }
}
```

### 3. Как вы видите порядок расчётов? (open → затем single)

1. Открытый вопрос:

```json
{
  "id": "service_contract.payment.description",
  "documentType": "service_contract",
  "text": "Как вы видите порядок расчётов по договору? Опишите своими словами.",
  "uiKind": "open",
  "valueType": "string",
  "isRequired": true,
  "affects": ["payment.rawDescription"]
}
```

2. После нормализации LLM может предложить уточняющий вопрос с выбором:

```json
{
  "id": "service_contract.payment.model",
  "documentType": "service_contract",
  "text": "Какой вариант лучше всего описывает порядок оплаты?",
  "uiKind": "single",
  "valueType": "enum",
  "isRequired": true,
  "options": [
    { "id": "fixed_monthly", "label": "Фиксированная сумма ежемесячно", "value": "fixed_monthly" },
    { "id": "per_hour", "label": "Почасовая оплата", "value": "per_hour" },
    { "id": "per_result", "label": "Оплата за результат", "value": "per_result" }
  ],
  "allowOther": true,
  "dependsOn": ["payment.rawDescription"],
  "affects": ["payment.model"]
}
```

---

## Использование вопросов в рантайме

1. Фронт получает список `Question` для выбранного `documentType`.
2. Функция выбора следующего вопроса:

   * фильтрует вопросы, у которых выполнены `dependsOn`;
   * отбрасывает уже отвеченные;
   * сортирует по `order` и/или рекомендациям LLM.
3. В зависимости от `uiKind` и `options` фронт рендерит:

   * текстовое поле (для `open`);
   * радио-кнопки (для `single`);
   * чекбоксы (для `multi`) и, при `allowOther`, дополнительное поле “Другое”.
4. После ответа:

   * сохраняется `QuestionAnswer` (сырые + нормализованные данные);
   * `normalized` мёржится в общий `context` будущего документа;
   * на основе обновлённого `context` выбирается следующий вопрос.

---

Эта схема позволяет:

* гибко комбинировать открытые и структурированные ответы;
* постепенно переучивать систему — сначала собирать “хаос” через `open`, потом на его основе вводить `single`/`multi`;
* жёстко привязывать каждый вопрос к конкретным полям контекста (`affects`), чтобы дальше использовать их при генерации скелета и формулировок документа.
