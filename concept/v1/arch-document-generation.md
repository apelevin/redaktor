# Архитектура генерации документа по скелетону

## Обзор

Генерация документа по скелетону — это четвертый шаг пайплайна создания юридического документа. На этом этапе система генерирует полный юридический текст документа на основе:
- **Скелета документа** (структура с разделами и пунктами), созданного на шаге 3. Если на шаге 2 пользователь выбрал инструкцию из Pinecone с высоким score, скелет берётся сразу из `instructionMatch.recommendedStructure` без вызова LLM.
- **Выбранных пользователем пунктов** из скелета
- **Сгенерированного контекста** (полное описание договора), созданного на шаге 2
- **Ответов пользователя** на уточняющие вопросы по каждому пункту скелета
- **Словаря терминов** (определения ключевых сущностей), созданного на шаге 3
- **Режима детализации** (выбранного пользователем перед генерацией)

После генерации пользователь может скачать документ в формате Markdown.

## Архитектура компонентов

### 1. Frontend: Step4Panel.tsx

**Расположение:** `app/components/Step4Panel.tsx`

**Ответственность:**
- Отображение процесса генерации документа
- Последовательная генерация текста для каждого выбранного пункта скелета
- Сборка полного текста документа из сгенерированных пунктов
- Отображение прогресса генерации
- Управление состоянием процесса генерации

**Ключевые состояния:**
- `isGenerating: boolean` — идет ли процесс генерации
- `currentItemIndex: number` — индекс текущего обрабатываемого пункта
- `generationComplete: boolean` — завершена ли генерация всех пунктов
- `error: string | null` — ошибки генерации

**Основные функции:**

#### `startGeneration()`
Инициирует процесс генерации документа. Вызывается автоматически при монтировании компонента, если есть выбранные пункты.

#### `generateNextItem(index: number)`
Рекурсивная функция, которая последовательно генерирует текст для каждого выбранного пункта скелета:

1. Проверяет, не превышен ли лимит пунктов
2. Если все пункты обработаны — вызывает `assembleFullDocument()`
3. Проверяет, не сгенерирован ли уже текст для текущего пункта (пропускает, если есть)
4. Отправляет запрос к API `/api/pipeline/document-item-generation`
5. Сохраняет сгенерированный текст через `addDocumentClause()`
6. Отслеживает затраты через `addCostRecord()`
7. Переходит к следующему пункту с небольшой задержкой (100ms)

#### `assembleFullDocument()`
Собирает полный текст документа из сгенерированных пунктов:

1. Проходит по структуре скелета
2. Для каждого раздела собирает тексты выбранных пунктов
3. Формирует итоговый документ с заголовками разделов в формате Markdown (`## Заголовок`)
4. Сохраняет результат через `setGeneratedDocument()`

#### `handleDownloadMarkdown()`
Скачивает сгенерированный документ в формате Markdown:

1. Использует `generatedDocument`, если он есть, иначе собирает из `documentClauses`
2. Форматирует документ с заголовками разделов в формате Markdown (`## Заголовок`)
3. Создает Blob с типом `text/markdown;charset=utf-8`
4. Генерирует имя файла: `{тип_документа}_{дата}.md`
5. Инициирует скачивание через создание временной ссылки

**Данные из store:**
- `documentType` — тип документа
- `generatedContext` — полное описание договора (из шага 2)
- `skeleton` — структура документа (разделы и пункты). При использовании инструкции из Pinecone (instructionMatch) скелет берётся из неё без вызова LLM.
- `selectedSkeletonItems` — Set выбранных пунктов (ключ: `sectionId-itemIndex`)
- `skeletonItemAnswers` — ответы пользователя по пунктам
- `documentClauses` — сгенерированные тексты пунктов
- `generatedDocument` — полный текст документа
- `documentMode` — режим генерации документа
- `outputTextMode` — режим детализации текста (short, standard, extended, expert)
- `terms` — словарь терминов и определений

### 2. API Endpoint: /api/pipeline/document-item-generation

**Расположение:** `app/api/pipeline/document-item-generation/route.ts`

**Метод:** POST

**Входные параметры:**
```typescript
{
  document_type: string;           // Тип документа
  generated_context: string;       // Полное описание договора
  section_title: string;          // Название раздела
  section_id: string;              // ID раздела
  item_text: string;              // Текст пункта из скелета
  item_index: number;              // Индекс пункта в разделе
  item_answers: any;               // Ответы пользователя по этому пункту
  existing_clauses: Record<string, string>; // Уже сгенерированные тексты
  jurisdiction?: string;           // Юрисдикция (опционально)
  style?: string;                  // Стиль документа (опционально)
  document_mode?: DocumentMode;    // Режим детализации текста (опционально)
  terms?: TermsDictionary | null;  // Словарь терминов и определений (опционально)
}
```

**Выходные данные:**
```typescript
{
  generatedText: string;           // Сгенерированный текст пункта
  usage?: TokenUsage;              // Использование токенов
  model?: string;                  // Использованная модель
}
```

**Логика:**
1. Валидирует обязательные параметры
2. Вызывает `generateDocumentItem()` из `lib/openai/document-item-generator.ts`
3. Возвращает результат с отслеживанием затрат

### 3. Document Item Generator: lib/openai/document-item-generator.ts

**Расположение:** `lib/openai/document-item-generator.ts`

**Ответственность:**
- Формирование промпта для генерации текста пункта
- Вызов OpenAI API для генерации текста
- Обработка ответов пользователя и уже сгенерированных текстов
- Возврат сгенерированного текста

**Основная функция:**

#### `generateDocumentItem(params: DocumentItemGenerationParams)`

**Процесс:**

1. **Форматирование ответов пользователя:**
   - Если `item_answers` — строка, используется как есть
   - Если объект — сериализуется в JSON
   - Если отсутствует — используется текст "Ответы пользователя не предоставлены."

2. **Форматирование существующих текстов:**
   - Преобразует `existing_clauses` (Record<string, string>) в читаемый текст
   - Формат: `Пункт sectionId-itemIndex:\n{текст}`
   - Если текстов нет — используется "Пока нет сгенерированных текстов."

3. **Сериализация словаря терминов:**
   - Преобразует `terms` (TermsDictionary) в текстовый формат
   - Формат: `"Термин" — Определение` (каждый термин на новой строке)
   - Если терминов нет — используется пустая строка

4. **Загрузка и рендеринг промпта:**
   - Загружает промпт из `prompts/document-item-generation.md`
   - Подставляет переменные:
     - `document_type`
     - `jurisdiction` (если указана)
     - `style` (если указан)
     - `generated_context`
     - `section_title`
     - `item_text`
     - `item_answers` (отформатированные)
     - `existing_clauses` (отформатированные)
     - `document_mode` (режим детализации, по умолчанию 'short')
     - `terms` (отформатированные)

5. **Вызов OpenAI API:**
   - Использует модель из конфигурации `clause_generation`
   - System message: инструкция для юридического эксперта
   - User message: сформированный промпт
   - `response_format: { type: 'text' }` — возвращает чистый текст
   - Поддерживает `reasoning_effort`, `verbosity` и `service_tier` (если доступны)
   - `service_tier` настраивается через конфигурацию модели (по умолчанию 'flex' для снижения затрат)

5. **Обработка ответа:**
   - Извлекает текст из `response.choices[0].message.content`
   - Обрабатывает использование токенов
   - Возвращает результат с текстом, usage и моделью

### 4. Промпт: prompts/document-item-generation.md

**Расположение:** `prompts/document-item-generation.md`

**Структура промпта:**

1. **Контекст договора:**
   - Тип документа
   - Юрисдикция (если указана)
   - Стиль (если указан)
   - Полное описание договора (`generated_context`)

2. **Текущий пункт для генерации:**
   - Название раздела
   - Текст пункта из скелета
   - Ответы пользователя по этому пункту

3. **Уже сгенерированные тексты:**
   - Для обеспечения согласованности формулировок, терминов и стиля

4. **Словарь терминов:**
   - Определения ключевых сущностей (объект, стороны, договор)
   - Используется для предотвращения дублирования длинных описаний
   - Правила использования коротких терминов vs полных определений в зависимости от режима документа

5. **Режим детализации:**
   - `short` — краткий формат (1 абзац или 3-6 предложений)
   - `standard` — стандартный формат (1-2 абзаца)
   - `extended` — расширенный формат (2-3 абзаца)
   - `expert` — экспертный формат (3+ абзаца)

6. **Требования:**
   - Использовать вводный контекст как основу
   - Учитывать ответы пользователя
   - Согласовывать с уже созданными текстами
   - Использовать термины из словаря для избежания дублирования
   - Быть конкретным (использовать конкретные значения)
   - Соблюдать юридическую корректность
   - Сохранять стиль документа
   - Обеспечивать последовательность
   - Соблюдать режим детализации

**Формат ответа:**
- Только текст пункта документа
- Без дополнительных пояснений, метаданных или JSON
- Готов для включения в документ

### 5. State Management: lib/store/document-store.ts

**Ключевые поля для генерации документа:**

```typescript
generatedContext: string | null;              // Описание договора (шаг 2)
skeleton: Section[] | null;                   // Структура документа
selectedSkeletonItems: Set<string>;          // Выбранные пункты
skeletonItemAnswers: Record<string, any>;     // Ответы по пунктам
documentClauses: Record<string, string>;     // Сгенерированные тексты
generatedDocument: string | null;            // Полный текст документа
documentMode: DocumentMode;                  // Режим генерации документа
outputTextMode: OutputTextMode | null;        // Режим детализации текста
terms: TermsDictionary | null;                // Словарь терминов и определений
```

**Ключевые действия:**

- `addDocumentClause(sectionId, itemIndex, text)` — сохраняет сгенерированный текст пункта
- `setGeneratedDocument(text)` — сохраняет полный текст документа
- `setOutputTextMode(mode)` — устанавливает режим детализации текста
- `addCostRecord(model, usage, operation)` — отслеживает затраты

## Поток данных

### Последовательность операций

1. **Инициализация (Step4Panel монтируется):**
   ```
   useEffect → startGeneration() → generateNextItem(0)
   ```

2. **Генерация пункта:**
   ```
   generateNextItem(index)
   ↓
   Проверка: все ли пункты обработаны?
   ├─ Да → assembleFullDocument() → завершение
   └─ Нет → Продолжение
   ↓
   Проверка: есть ли уже текст для пункта?
   ├─ Да → Пропуск → generateNextItem(index + 1)
   └─ Нет → Продолжение
   ↓
   POST /api/pipeline/document-item-generation
   (с параметрами: document_mode, terms)
   ↓
   generateDocumentItem()
   ↓
   Форматирование данных (включая terms) → Загрузка промпта → OpenAI API
   (с service_tier из конфигурации)
   ↓
   Сохранение результата (addDocumentClause)
   ↓
   Отслеживание затрат (addCostRecord)
   ↓
   generateNextItem(index + 1)
   ```

3. **Сборка документа:**
   ```
   assembleFullDocument()
   ↓
   Проход по skeleton
   ↓
   Для каждого раздела:
   ├─ Фильтрация выбранных пунктов
   ├─ Сбор текстов из documentClauses
   └─ Формирование структуры с заголовками в формате Markdown (## Заголовок)
   ↓
   setGeneratedDocument(fullText)
   ```

4. **Скачивание документа:**
   ```
   handleDownloadMarkdown()
   ↓
   Проверка: есть ли generatedDocument?
   ├─ Да → Использовать generatedDocument
   └─ Нет → Собрать из documentClauses с заголовками Markdown
   ↓
   Создание Blob (text/markdown)
   ↓
   Генерация имени файла: {documentType}_{дата}.md
   ↓
   Инициация скачивания через временную ссылку
   ```

### Формат ключей

- **Выбранные пункты:** `sectionId-itemIndex` (например, `"section-1-0"`)
- **Ответы пользователя:** `sectionId-itemIndex` → объект с ответами
- **Сгенерированные тексты:** `sectionId-itemIndex` → строка с текстом

## Особенности реализации

### Последовательная генерация

Генерация происходит **последовательно**, пункт за пунктом, а не параллельно. Это обеспечивает:
- **Согласованность** — каждый следующий пункт учитывает уже сгенерированные тексты
- **Контроль затрат** — можно отслеживать прогресс и затраты по каждому пункту
- **Обработка ошибок** — при ошибке процесс останавливается, не тратя ресурсы на остальные пункты

### Кэширование результатов

Если текст для пункта уже сгенерирован (есть в `documentClauses`), он пропускается. Это позволяет:
- Перезапускать генерацию без дублирования работы
- Генерировать только недостающие пункты

### Согласованность текста

Для обеспечения согласованности в промпт включаются:
- **Уже сгенерированные тексты** — для использования тех же формулировок и терминов
- **Полный контекст договора** — для понимания общей картины
- **Ответы пользователя** — для включения конкретных деталей
- **Словарь терминов** — для предотвращения дублирования длинных описаний и обеспечения единообразия терминологии

### Отслеживание затрат

Каждый вызов API отслеживается через `addCostRecord()`:
- Модель
- Использование токенов (prompt, completion, total, cached)
- Операция: `'document_generation'`
- Временная метка
- Стоимость

## Пример использования

### Входные данные

**Скелет:**
```json
[
  {
    "id": "section-1",
    "title": "Предмет договора",
    "items": [
      "Предмет договора и его характеристики",
      "Права и обязанности сторон"
    ]
  }
]
```

**Выбранные пункты:**
```typescript
selectedSkeletonItems = new Set(["section-1-0", "section-1-1"])
```

**Ответы пользователя:**
```typescript
skeletonItemAnswers = {
  "section-1-0": {
    questionId: "skeleton-item-1",
    raw: "Автомобиль Range Rover 2020 года, VIN: 534-848-38"
  }
}
```

**Сгенерированный контекст:**
```
Договор купли-продажи автомобиля между физическими лицами...
```

### Процесс генерации

1. **Пункт 1 (section-1-0):**
   - Промпт включает: контекст, текст пункта, ответ пользователя
   - Генерируется текст: "Предметом настоящего договора является автомобиль Range Rover 2020 года выпуска, идентификационный номер (VIN): 534-848-38..."
   - Сохраняется в `documentClauses["section-1-0"]`

2. **Пункт 2 (section-1-1):**
   - Промпт включает: контекст, текст пункта, ответ пользователя (если есть), **уже сгенерированный текст пункта 1**
   - Генерируется текст с учетом формулировок из пункта 1
   - Сохраняется в `documentClauses["section-1-1"]`

3. **Сборка:**
   - Формируется документ:
     ```
     Предмет договора
     
     Предметом настоящего договора является автомобиль...
     
     Права и обязанности сторон
     
     [Текст пункта 2]
     ```

## Обработка ошибок

- **Ошибка API:** Останавливается генерация, ошибка отображается пользователю
- **Пустой ответ:** Генерируется ошибка "Empty response from OpenAI"
- **Отсутствие обязательных параметров:** API возвращает 400 с описанием ошибки
- **Ошибка сервера:** API возвращает 500 с общим сообщением

## Производительность

- **Задержка между пунктами:** 100ms (для плавности UI)
- **Параллелизация:** Не используется (для согласованности)
- **Кэширование:** Результаты сохраняются в store, повторная генерация не требуется
- **Service Tier:** По умолчанию используется `flex` для снижения затрат. Настраивается через переменные окружения:
  - `OPENAI_SERVICE_TIER` — глобальная настройка
  - `OPENAI_SERVICE_TIER_CLAUSE_GENERATION` — настройка для генерации пунктов

## UI Компоненты

### Выбор режима детализации

Перед началом генерации пользователь может выбрать режим детализации текста:
- **Краткий** (`short`) — 1 абзац или 3-6 предложений
- **Стандартный** (`standard`) — 1-2 абзаца
- **Расширенный** (`extended`) — 2-3 абзаца
- **Экспертный** (`expert`) — 3+ абзаца

Режим передается в каждый запрос генерации и влияет на детализацию сгенерированного текста.

### Скачивание документа

После завершения генерации доступны две кнопки "Скачать Markdown":
1. В блоке "✓ Генерация документа завершена" (появляется после завершения)
2. В заголовке секции "Сгенерированный текст документа" (доступна, когда есть сгенерированные тексты)

Документ скачивается в формате Markdown с:
- Заголовками разделов в формате `## Заголовок`
- Именем файла: `{тип_документа}_{дата}.md`
- Полным текстом всех выбранных пунктов

## Расширяемость

Архитектура позволяет легко:
- Добавить поддержку новых типов документов
- Изменить модель генерации через конфигурацию
- Добавить дополнительные параметры в промпт
- Реализовать параллельную генерацию (если потребуется)
- Добавить валидацию сгенерированных текстов
- Добавить поддержку других форматов экспорта (DOCX, PDF и т.д.)
- Настроить `service_tier` для оптимизации затрат через переменные окружения

