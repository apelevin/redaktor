Да, это как раз то, что нужно “зашить” в сам пайплайн — чтобы он **сам** понимал: вопросов больше не надо. Давай опишу без кода, только логику.

---

## 1. Что хранится в состоянии

В store у тебя есть:

* **Список блоков**:
  для каждого блока:

  * `requiredLevel`: `must / recommended / optional`
  * `status`: `inactive / active / completed`
* **Контекст** (ответы пользователя).

Важно: статус `completed` ставится не LLM “на глаз”, а по понятным правилам:

* ключевой вопрос блока задан,
* минимальные поля блока заполнены.

---

## 2. Что делает LLM на каждом шаге

Цикл:

1. Пользователь отвечает на вопрос.
2. Бэкенд обновляет контекст.
3. LLM получает:

   * текущий список блоков со статусами,
   * контекст,
   * историю вопросов/ответов.
4. LLM возвращает:

   * какие блоки активировать/деактивировать,
   * какие блоки считать завершёнными,
   * какой блок сейчас приоритетный для уточнения,
   * черновой текст следующего вопроса **или** сигнал “вопросов больше не нужно”.

Но даже если LLM скажет “всё, хватит”, окончательное решение принимает не он, а твоя логика на бэке.

---

## 3. Жёсткое правило остановки на бэке

После применения изменений от LLM ты всегда делаешь **детерминированную проверку**:

1. Считаешь:

   * сколько `must`-блоков всего,
   * сколько `must`-блоков в статусе `completed`.

2. Если есть хотя бы один `must`-блок, который:

   * `active` или `inactive` (то есть так и не закрыт),
     → **продолжаем задавать вопросы** (ищем следующий `must`).

3. Если **все `must`-блоки в `completed`**:

   * система фиксирует флаг:
     `canGenerateContract = true`
   * и больше **не обязана** задавать вопросы.

Это и есть точный сигнал:

> “минимальный юридический набор собран, можно прекращать задавать вопросы”.

LLM в этот момент может ещё предлагать рекомендованные уточнения, но это уже не влияет на `canGenerateContract`.

---

## 4. Как это выглядит в пайплайне

После каждого шага у тебя есть развилка:

1. **Проверка must-блоков в store**:

   * если `canGenerateContract = false` → берём от LLM следующий вопрос и продолжаем диалог;
   * если `canGenerateContract = true` → **запрещаем** LLM выдавать вопросы как “обязательные”.

2. Дальше можно сделать два режима:

**Режим по умолчанию**
Если `canGenerateContract = true`, фронт:

* показывает кнопку “Сформировать договор” (активна),
* а LLM, если хочет, может предложить 1–2 важных рекомендованных уточнения с явным выбором:

  * “Сразу к договору”
  * “Ещё пара уточнений”.

**Режим авто-стопа**
Если `canGenerateContract = true`, а пользователь явно жмёт “дальше” без выбора — ты сразу переходишь к генерации договора, не давая LLM шанс задать лишний вопрос.

---

## 5. Двойной контур безопасности

Чтобы стоп-сигнал был железобетонным, делаешь два уровня:

1. **LLM-уровень** — он сам может вернуть поле типа `shouldStop: true`, если видит, что все обязательные зоны закрыты.
2. **Backend-уровень** — независимая проверка по состоянию блоков в store (must/ completed).

   * Если LLM ошибся — бэкенд его поправит.
   * Если LLM “забыл, что стоп”, бэкенд всё равно не позволит продолжать бесконечные вопросы.

---

### В одном предложении

Алгоритм даёт стоп-сигнал так:

> после каждого шага мы пересчитываем статусы блоков, и как только все блоки уровня `must` в store становятся `completed`, бэкенд фиксирует `canGenerateContract = true` и переводит систему из режима “обязательных вопросов” в режим “опциональные уточнения или сразу генерация договора”.
