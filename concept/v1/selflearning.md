Ниже текст, который можно прямо вставлять в Cursor как техзадание/описание концепции.

---

## Концепция: самообучающийся контрактный редактор на базе двух RAG-индексов

### 1. Цель

Сделать пайплайн генерации договоров, который **сам себя обучает** на сохранённых документах:

* при создании нового документа система:

  * сначала ищет **готовую инструкцию** (skeleton) по типу договора;
  * затем для каждого раздела skeleton-а ищет **готовые формулировки** (clauses);
  * только если ничего подходящего нет — вызывает LLM для генерации;
* как только пользователь сохраняет документ, его:

  * **skeleton превращается в новую instruction** и попадает в Pinecone;
  * **каждая клауза попадает в Pinecone как отдельная запись** для дальнейшего переиспользования.

Юрисдикция и язык всегда одни и те же: **РФ, русский**. Это упрощает метаданные и фильтрацию.

---

### 2. Используемые векторы и модели

**Модель эмбеддингов:**

* `text-embedding-3-small` (OpenAI)
* применяем для ВСЕХ записей в обоих Pinecone-индексах.

**Модели генерации (LLM):**

* дешёвые вспомогательные шаги (вопросы, summaries, вытаскивание переменных, сборка JSON)
  → `gpt-5-mini` (Batch/Flex)
* сложные юридические шаги (генерация клаузы, когерентность/проверка противоречий)
  → `gpt-5.1` (Batch/Flex)

---

### 3. Индексы в Pinecone

Используются два индекса:

```env
PINECONE_INSTRUCTIONS_INDEX = "instructions"
PINECONE_CLAUSES_INDEX      = "clauses"
```

#### 3.1. Index `instructions`

**Назначение:**
быстрая выдача **готового skeleton-а / инструкции** по типу документа и стилю.

Каждая запись в этом индексе описывает **один “рецепт”** документа (как его структурировать).

**Текст для эмбеддинга** (пример):

```text
Тип: договор поставки. Стиль: строгий, B2B, РФ.
Оглавление:
1. Предмет договора
2. Порядок поставки
3. Цена и порядок расчётов
4. Ответственность сторон
5. Порядок разрешения споров
6. Срок действия и прочие условия

Краткий контекст: поставка оборудования между коммерческими организациями.
```

**Метаданные записи** (примерная схема, JSON):

```json
{
  "document_type": "договор поставки",
  "style": "строгий",               // или "лаконичный", "friendly", и т.п.
  "skeleton_id": "skl_123",         // ID skeleton-а в нашей БД
  "source_doc_id": "doc_456",       // из какого документа получилось
  "approved": true,                 // юрист подтвердил, что можно использовать как best practice
  "version": 1,
  "usage_count": 3                  // сколько раз skeleton реально использовали
}
```

Поля `jurisdiction` и `language` можно не хранить, т.к. все документы РФ / русский.

---

#### 3.2. Index `clauses`

**Назначение:**
поиск и переиспользование **конкретных формулировок** по разделам договора.

Каждая запись — это **одна клауза** (пункт/подпункт), которую потом можно:

* либо вставить как есть,
* либо слегка адаптировать через LLM.

**Текст для эмбеддинга** (пример):

```text
Тип: договор поставки. Стиль: строгий, B2B, РФ.
Раздел: 4. Ответственность сторон
Подраздел: 4.2. Ответственность за просрочку оплаты

Текст:
Покупатель уплачивает Поставщику неустойку в размере 0,1% от суммы просроченного платежа за каждый день просрочки, но не более 10% от общей цены Договора.
```

**Метаданные записи** (примерная схема):

```json
{
  "document_type": "договор поставки",
  "style": "строгий",
  "section_path": "4.2. Ответственность за просрочку оплаты", // путь внутри skeleton
  "source_doc_id": "doc_456",
  "approved": true,             // клауза проверена юристом
  "quality_score": 0.9,         // можно завести метрику качества
  "penalty_rate": "0.1%",       // опционально: извлечённые переменные
  "penalty_cap": "10%"
}
```

Структурные поля (`penalty_rate`, `penalty_cap` и т.д.) не участвуют в семантическом поиске, но могут использоваться при сборке JSON-документа.

---

### 4. Как Pinecone встраивается в текущий пайплайн

Текущая последовательность шагов:

1. Вход: `document_type`, `style` (юрисдикция = РФ по умолчанию).
2. Поиск инструкции (RAG).
3. Сбор контекста (диалог).
4. Генерация skeleton-а.
5. Для каждого раздела skeleton:

   * поиск клаузы в RAG,
   * при неуспехе → генерация через LLM.
6. Параллельно:

   * обновление `contract_variables`,
   * обновление `clauses_summary`,
   * проверка когерентности.
7. Сборка документа.
8. Вывод, редактирование, экспорт.
9. После сохранения документа — инжест в Pinecone (instructions + clauses).

Ниже — более детально только RAG-часть.

---

### 5. Поиск инструкции (index `instructions`)

Шаг выполняется после того, как пользователь выбрал тип документа и стиль, но до диалога и генерации skeleton-а.

**Вход:**

* `document_type` (строка: например, `"договор поставки"`)
* `style` (строка: например, `"строгий"`)

**Запрос:**

Формируем текстовый запрос:

```text
Тип: договор поставки. Стиль: строгий, B2B, РФ.
Нужно типовое оглавление и структуру договора.
```

1. Считаем эмбеддинг через `text-embedding-3-small`.
2. Делаем запрос в Pinecone index `instructions`:

   * topK = например 5–10,
   * фильтр по метаданным:

     * `document_type == выбранный_тип`,
     * `approved == true` (по умолчанию берём только подтверждённые).
3. Берём лучший результат (`top-1`) и его `score`.

**Ветвление:**

* если `score >= INSTRUCTION_THRESHOLD` (например 0.75–0.8):

  * считаем, что **инструкция найдена**:

    * подтягиваем из своей БД skeleton по `skeleton_id`,
    * пропускаем шаги **“Сбор контекста”** (опционально) и **“Генерация skeleton-а”**,
    * переходим напрямую к шагу обработки разделов (поиск/генерация клауз).
* если `score < порога`:

  * считаем, что подходящей инструкции нет,
  * переходим к диалоговому сбору контекста и последующей генерации skeleton-а через LLM.

---

### 6. Поиск клаузы (index `clauses`)

Этот шаг выполняется **для каждого раздела skeleton**.

**Вход:**

* `document_type`
* `style`
* описание текущего раздела `current_section` (например, `"Ответственность за просрочку оплаты"`)

**Формирование запроса:**

```text
Тип: договор поставки. Стиль: строгий, B2B, РФ.
Нужна клауза для раздела: "Ответственность за просрочку оплаты".
```

1. Считаем эмбеддинг через `text-embedding-3-small`.
2. Делаем запрос в Pinecone index `clauses`:

   * topK = 5–10,
   * фильтр:

     * `document_type == выбранный_тип`,
     * `approved == true`,
     * (опционально) `style == выбранный_стиль` или `style in [выбранный_стиль, "any"]`.
3. Берём top-1 с максимальным `score`.

**Ветвление:**

* если `score >= CLAUSE_THRESHOLD` (например 0.75–0.8):

  * считаем, что **готовая клауза найдена**;
  * используем текст клаузы как основу:

    * либо вставляем как есть,
    * либо слегка адаптируем через LLM (подставить нужные суммы, даты, имена и т.п.);
  * **генерацию с нуля через LLM пропускаем**.
* если `score < порога`:

  * считаем, что подходящей клаузы нет;
  * вызываем LLM (`gpt-5.1`) для генерации новой клаузы с нуля, используя:

    * `document_type`, `current_section`, `style`,
    * `qa_context`,
    * текущее состояние `contract_variables`,
    * summaries предыдущих клауз.

---

### 7. Инжест в Pinecone при сохранении документа

Этот шаг выполняется, когда пользователь нажал **“Сохранить документ”**.

Срабатывает отдельный ingestion-процесс/воркер, который делает два типа upsert-ов.

#### 7.1. Инжест skeleton-а в `instructions`

1. Берём финальный `skeleton` документа (уже с учётом возможных ручных правок).
2. Формируем текст для эмбеддинга:

```text
Тип: {document_type}. Стиль: {style}, B2B, РФ.
Оглавление:
{список разделов и подпунктов}

Краткий контекст: {опционально — краткое описание случая, если есть}.
```

3. Считаем эмбеддинг через `text-embedding-3-small`.
4. Формируем метаданные:

```json
{
  "document_type": "...",
  "style": "...",
  "skeleton_id": "...",
  "source_doc_id": "...",
  "approved": false,        // по умолчанию можно ставить false
  "version": 1,
  "usage_count": 0
}
```

5. Делаем `upsert` в Pinecone index `instructions`.

*(Если в продуктовой логике есть модерация юристом, то после утверждения skeleton-а можно выставить `approved = true`.)*

#### 7.2. Инжест клауз в `clauses`

1. Проходим по всем `clauses[]` итогового документа.

2. Для каждой:

   * формируем текст для эмбеддинга:

     ```text
     Тип: {document_type}. Стиль: {style}, B2B, РФ.
     Раздел: {section_title}
     Подраздел: {section_path}

     Текст:
     {полный текст клаузы}
     ```

   * считаем эмбеддинг через `text-embedding-3-small`;

   * формируем метаданные:

     ```json
     {
       "document_type": "...",
       "style": "...",
       "section_path": "...",
       "source_doc_id": "...",
       "approved": false,          // по умолчанию
       "quality_score": 0.0,       // можно задать позже
       // опционально — структурные переменные:
       "penalty_rate": "...",
       "penalty_cap": "..."
     }
     ```

3. Делаем `upsert` в Pinecone index `clauses`.

---

### 8. Политика качества и версионирования

Чтобы база не “засорялась”, важно:

1. **Флаг `approved`**

   * по умолчанию новые skeleton-ы и клаузы создаются с `approved = false`;
   * RAG-квери по умолчанию фильтруют `approved == true`;
   * админ-интерфейс для юриста: просмотр новых записей, выставление `approved = true`.

2. **`usage_count` и `quality_score`**

   * `usage_count` увеличивается, если instruction/клауза действительно были выбраны пайплайном и вошли в финальный документ;
   * на основе обратной связи от юристов/пользователей можно повышать `quality_score`.

3. **Версии**

   * у instruction-ов есть `version` + флаг `is_latest` (по желанию);
   * при существенном изменении skeleton-а добавляется новая версия, старая помечается как неактуальная (`is_latest = false`).

---

### 9. Краткая сводка для разработки

* **Модель эмбеддингов:** `text-embedding-3-small`.
* **Индексы Pinecone:**

  * `instructions` — хранит skeleton-инструкции (поиск по типу договора/стилю).
  * `clauses` — хранит клаузы (поиск по разделу).
* **Использование в пайплайне:**

  * шаг “Поиск инструкции” → запрос в `instructions` → при успехе пропускаем генерацию skeleton-а;
  * шаг “Поиск клаузы” для каждого раздела → запрос в `clauses` → при успехе пропускаем генерацию клаузы.
* **Инжест при сохранении документа:**

  * skeleton → upsert в `instructions`;
  * все клаузы → upsert в `clauses`.

Этот текст можно использовать как основное описание концепции и основу для реализации сервисов:

* `InstructionRagService` (search + upsert),
* `ClauseRagService` (search + upsert),
* ingestion-хендлер `onDocumentSaved`, который вызывает оба.
