Опишу как конвейер из модулей, без текстов промптов — только логика и потоки данных. 

---

## 1. Вход и общие сущности

На вход пайплайна попадает:

* `document_type` — тип документа (договор поставки, подряд, NDA и т.п.)
* опционально `jurisdiction`, `style`
* `qa_context` — постепенно растущая история вопросов/ответов
* состояние документа:

  * `skeleton` — структура документа
  * `clauses` — уже сгенерированные пункты
  * `contract_variables` — ключевые переменные (срок, ставка неустойки и т.д.)
  * `clauses_summary` — краткие конспекты уже созданных клауз

---

## 2. Блок «Инструкция» (RAG для методики)

**Цель:** понять, есть ли готовый рецепт для этого типа документа.

1. Модуль *Instruction Retrieval* делает запрос в RAG:

   * по `document_type` (+ фильтры: RU, актуальность).
2. Ветвление:

   * **Если инструкция найдена**
     → на выходе: набор вопросов, skeleton, ссылки на нормы.
   * **Если инструкции нет**
     → флаг `instruction_found = false`, переходим к диалоговому сбору контекста с LLM.

---

## 3. Блок «Сбор контекста» (итеративный диалог)

**Цель:** собрать минимально достаточный юридический контекст.

1. Инициализируется пустой `qa_context = []`.
2. Цикл:

   * модуль *Next Question* получает `document_type` + `qa_context`;
   * возвращает либо следующий уточняющий вопрос, либо сигнал «вопросов больше нет».
3. Пользователь отвечает, ответ добавляется в `qa_context`.
4. Цикл продолжается, пока модуль не вернёт «вопросов больше нет».

Выход блока: полный `qa_context` для последующих шагов.

---

## 4. Блок «Генерация skeleton-а»

**Цель:** получить оглавление документа.

Варианты:

1. **Если из инструкции уже пришёл skeleton**
   → просто используем его как базовую структуру.
2. **Если инструкции не было**

   * модуль *Skeleton Generator* берёт:

     * `document_type`
     * `qa_context`
     * опционально `jurisdiction`, `style`
   * формирует упорядоченный список разделов и подпунктов `skeleton`.

Дополнительно: skeleton показывается пользователю на подтверждение и может быть скорректирован вручную.

---

## 5. Блок «Проход по skeleton: поиск формулировки в RAG»

**Цель:** для каждого пункта skeleton сначала попытаться найти готовый юридический текст в базе.

Для каждого `current_section` из `skeleton`:

1. Модуль *Clause Retrieval (RAG)* получает:

   * `document_type`
   * `current_section`
   * `qa_context`
   * `jurisdiction`
2. Делается семантический поиск по корпоративным шаблонам / законам / кейсам.
3. Ветвление:

   * **Если найдена клауза c достаточной релевантностью**
     → возвращается `retrieved_clause` + метаданные источника, клауза добавляется в `clauses`.
   * **Если не найдена**
     → флаг `clause_found = false`, переход в блок генерации через LLM.

---

## 6. Блок «Генерация клаузы через LLM»

**Цель:** создать пункт, если RAG не дал подходящий текст.

Модуль *Clause Generator* получает:

* `document_type`
* `current_section`
* `qa_context`
* `jurisdiction`, `style`
* `related_norms` (если пришли ранее)
* `clauses_summary` (резюме уже существующих пунктов)
* `contract_variables` (глобальные параметры договора)

На выходе:

* `generated_clause`
* `assumptions` (какие допущения сделаны)
* `related_norms` (если модель их определила)

Клауза добавляется в:

* `clauses`
* `clauses_summary` (краткое описание для будущего контекста)
* при необходимости обновляются `contract_variables` (например, если в клаузе впервые явно появилась ставка неустойки).

---

## 7. Блок «Когерентность и внутренняя память документа»

Это поперечный слой, который работает параллельно с блоками 5–6:

1. **Юридическая память:**

   * после каждой клаузы:

     * формируется краткий summary;
     * обновляется JSON с `contract_variables`;
   * эти структуры подмешиваются в каждый следующий запрос к LLM.

2. **Проверка согласованности:**

   * отдельный модуль *Consistency Check* сравнивает новую клаузу с:

     * `clauses_summary`
     * `contract_variables`
   * на выходе:

     * `is_consistent` (true/false)
     * список конфликтов и рекомендованное исправление.
   * если есть конфликты:

     * либо авто-правка через LLM,
     * либо показ пользователю с подсветкой проблемных мест.

3. **Временный RAG по самому документу:**

   * все клаузы индексируются во временную векторную базу «draft_doc_index»;
   * перед генерацией очередной клаузы ищутся похожие пункты (по теме «срок», «ответственность», «расторжение» и т.п.);
   * если находят потенциально конфликтующие/дублирующие фрагменты — эта информация передаётся в LLM как предупреждение.

---

## 8. Блок «Сборка и вывод результата»

После обработки всех пунктов `skeleton`:

1. Модуль *Document Assembler*:

   * соединяет `skeleton` и `clauses` в один структурированный документ;
   * сохраняет связь: каждый текстовый блок знает свой `current_section` и, при необходимости, ссылку на источник (RAG/LLM).

2. Интерфейс показывает пользователю:

   * финальный текст договора с разделами и пунктами;
   * опционально — метки источника (шаблон, закон, кейс, сгенерировано ИИ);
   * статус когерентности (если реализовано).

3. Пользователь может:

   * отредактировать пункты вручную,
   * экспортировать документ,
   * сохранить как новый шаблон/инструкцию для RAG (замыкая цикл самообучения базы).
