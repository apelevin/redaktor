Понял: **не трогаю юридическую корректность**, даю **структурные, архитектурные абстракции**, которые стоит заложить в систему, чтобы такие документы получались аккуратно, предсказуемо и удобны для HITL/редактирования.

Я посмотрел твой пример-документ и по нему видно несколько типичных структурных паттернов/проблем, которые архитектура должна уметь **производить, контролировать и валидировать**: повторы однотипных разделов, “плавающая” нумерация, секции с разными уровнями вложенности, блоки “Примечание: Покрывает…”, отдельные “пакеты” условий (задаток, освобождение дома), реквизиты сторон и подписи. 

---

## 1) Документ как дерево, а не текст

### Абстракция

Храни документ не как `finalText`, а как **AST (Document Tree)**:

* `Document → Sections → Clauses → Subclauses → Paragraphs`
* у каждого узла:

  * `id` (стабильный),
  * `title`,
  * `content`,
  * `children`,
  * `numbering` (генерируемое),
  * `meta` (покрытие issues, источники решений, TODO).

Это решит разом:

* нумерацию,
* вложенность,
* подсветку в UI,
* сборку итогового текста,
* диффы/перезапись только нужных узлов.

---

## 2) Разделяй “смысловые блоки” и “общие boilerplate секции”

В документе видно, что “Споры/право/форс-мажор/ответственность” появляются в нескольких местах и даже повторяются разными версиями. 
Чтобы архитектура не плодила дубликаты, введи:

### Абстракция: `Block` и `Instance`

* `BlockDefinition` — канонический смысловой блок (например, DISPUTE_RESOLUTION).
* `BlockInstance` — его включение в конкретный документ (возможно, в одном месте).

И правило:

* **в документе должен быть максимум 1 instance каждого global-блока**, если не указано иное.

---

## 3) “Coverage metadata” как отдельный слой, не частью текста

У тебя много строк вида `*Примечание: Покрывает...*`. 
Это суперполезно для агента, но это **не должно попадать в финальный документ** (или должно уметь выключаться).

### Абстракция

Раздели:

* `clause.text` — финальный текст
* `clause.meta.coverage` — какие issues/blocks/decisions покрывает
* `clause.meta.comments` — внутренние заметки/обоснования

И введи режимы рендера:

* **exportMode: "clean" | "with_comments" | "with_audit"**

---

## 4) Нормализация структуры: единая схема секций + единая нумерация

В примере явно плавает нумерация (секции “1.1.”, “4.”, “11.”) и местами секции повторяются. 

### Абстракция: `NumberingPolicy`

Введи политику нумерации как независимый модуль:

* `decimal` (1, 1.1, 1.1.1)
* “ГОСТ-стайл”
* “без нумерации” (basic level)

И правило:

* нумерация **не хранится как текст**, а **рендерится** при экспорте из дерева.

---

## 5) “Точки обязательного ввода” (Required Inputs) как системная сущность

У тебя в тексте много плейсхолдеров: `[ФИО]`, `[адрес]`, `[кадастровый номер]`, `[сумма]`. 
Архитектура должна не просто “оставлять скобки”, а понимать:

* что это **обязательный параметр**,
* к чему он относится,
* как его запросить через чат (кнопки/формы),
* как валидировать формат (ИНН, ОГРН, кадастровый номер и т.д.).

### Абстракция: `RequiredInput`

```ts
interface RequiredInput {
  key: string;                    // "house.cadastralNumber"
  label: string;                  // "Кадастровый номер жилого дома"
  type: "string"|"date"|"money"|"enum"|"party"|"address";
  required: true;
  formatHint?: string;            // regex/описание формата
  relatesToNodeId: string;        // clause/section id для подсветки
  askMethod: "chat_form"|"chat_choice";
}
```

---

## 6) “Стороны и реквизиты” как отдельная подсистема (Party Registry)

В документе отдельно есть:

* преамбула со сторонами,
* “полные реквизиты сторон”,
* подписи. 

Это не просто текстовые блоки, это **единая модель субъектов**, от которой зависят:

* термины (“Продавец/Покупатель”),
* правильные поля реквизитов,
* генерация подписи,
* вставка данных в разные места.

### Абстракция: `PartyRegistry`

* `ContractParty[]` (structured)
* `PartyRoleMapping` (кто “Продавец”, кто “Покупатель”)
* `Renderers`:

  * `renderPreamble(parties)`
  * `renderRequisitesTable(parties)`
  * `renderSignatures(parties)`

И правило:

* агент не пишет “реквизиты” текстом вручную — он **рендерит их** из структуры.

---

## 7) Пакеты приложений/приложений и “встроенные” допусловия

В примере встречаются блоки, которые логически похожи на “допусловия”:

* задаток/аванс,
* срок освобождения дома,
* акт приёма-передачи. 

### Абстракция: `Annex` / `OptionalPackage`

Раздели:

* основной договор
* приложения/доп.условия как пакеты, которые можно включать/выключать

Это идеально вяжется с твоим `reasoningLevel`:

* basic: меньше пакетов
* professional: больше пакетов + детализация

---

## 8) Встроенная дедупликация и “конфликт-детектор” структуры

Раздел “Ответственность” и “Споры” встречаются больше одного раза, местами разными редакциями. 
Это не юридическая оценка — это чисто структурная проблема.

### Абстракция: `StructureLinter`

Добавь hard-checks:

* duplicate blocks (DISPUTE_RESOLUTION appears twice)
* duplicate semantics (по сигнатурам или тегам)
* conflicting decisions (в одном месте “Арбитражный суд Москвы”, в другом — “судебные органы РФ”)

---

## 9) Слой “разделение генерации на этапы”: сначала структура, потом наполнение

В твоём документе видно, что текст часто появляется до того, как корректно собрана структура (например, в “Цена договора…” вставлены условия про срок действия/пролонгацию). 

### Абстракция: Strict 2-phase generation

* Phase A: **Structure Plan**

  * профиль → блоки → skeleton
* Phase B: **Content Fill**

  * для каждого блока — требования → текст

И правило:

* генератор пункта не должен менять структуру, только наполнять.

---

## 10) Режим “Коротко/Стандарт/Профи” должен управлять *структурой*, а не только стилем

Практически:

* `basic` должен делать:

  * fewer blocks
  * fewer subclauses
  * более крупные секции
* `professional`:

  * more blocks/packages
  * больше subclauses
  * отдельные секции для специфических вещей (например, претензионный порядок как отдельный блок)

Это лучше реализовать через `DocumentSizePolicy` + правила включения блоков.

---

# Что добавить в архитектуру одним списком

1. `DocumentAST` (иерархия узлов + стабильные id)
2. `BlockCatalog` (канонические блоки) + `BlockInstance` (включения)
3. `CoverageMetadata` отдельно от текста + режимы экспорта (clean/audit)
4. `NumberingPolicy` как рендерер (нумерация не хранится в тексте)
5. `RequiredInputs` как список “пустых обязательных полей” + чат-формы
6. `PartyRegistry` (стороны/реквизиты/подписи как структура и рендереры)
7. `OptionalPackages/Annexes` (включаемые блоки типа “задаток”, “акт”)
8. `StructureLinter` (дедупликация блоков, конфликт-детектор)
9. 2-phase generation: сначала skeleton, потом текст
10. `ReasoningLevel` управляет включением блоков и глубиной дерева

---
