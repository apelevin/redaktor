# ЗАДАНИЕ ДЛЯ CURSOR: Этап `SKELETON_REVIEW` (настройка Skeleton Draft через UX-вопросы)

## Контекст

У нас уже есть:

* `pre_skeleton` (миссия + domain + issues + gate)
* `skeleton_draft` (дерево `document → section → clause`, без текста договора, с `tags/purpose/requires/include_if`)

Теперь нужно реализовать промежуточный этап **SKELETON_REVIEW**, который:

1. генерирует **набор UX-вопросов** на основе `mission + domain + skeleton_draft`,
2. показывает их пользователю в виде **чекбоксов / радиокнопок / полей ввода**,
3. применяет ответы к состоянию, **меняя структуру skeleton** (включая/выключая узлы, выбирая варианты, уточняя параметры),
4. после 1–2 итераций фиксирует структуру как `skeleton_final` (freeze).

Важно: система работает **для любых договоров**, без предопределённых типов договоров или банков вопросов в коде.

---

## Цель

Сделать так, чтобы пользователь мог:

* **расширять/сокращать структуру** (разделы/пункты),
* выбирать **варианты структуры** (коротко/подробно),
* быстро закрывать “структурные” развилки через удобный UX.

Результат этапа:

* `state.document.skeleton_final` (обновлённый skeleton),
* `state.document.freeze.structure = true`,
* `next_action = proceed_to_clause_requirements` (следующий этап генерации требований/текста).

---

## Принципы (обязательные)

1. **Абстрактность**: никаких hardcode-правил “для трудового договора делай X”. Решения строятся из `tags + requires + include_if + mission + issues`.
2. **Код не знает доменных полей**: `state.domain` — свободный JSON.
3. **Изменения структуры не через “удаление”**:

   * узлы не удаляются физически,
   * используется `status: active|omitted` и/или `enabled: true|false`,
   * либо `variant` (short/full) для узла.
4. **После freeze** запрещено добавлять новые секции/пункты (только дальнейшая генерация текста).
5. **LLM генерирует вопросы и патчи**, но оркестратор валидирует и применяет.

---

## Изменения в состоянии (State)

Добавить (или расширить) секции:

### 1) `state.document.skeleton_draft`

уже есть

### 2) `state.review`

новый блок:

* `state.review.questions` — массив UX-вопросов
* `state.review.answers` — ответы пользователя (в универсальном формате)
* `state.review.iteration` — номер итерации review (0,1,2)
* `state.review.status` — collecting|ready_to_apply|applied|frozen

### 3) `state.document.skeleton_final`

финальный skeleton после review

### 4) `state.document.freeze.structure`

boolean

---

## Новые JSON-схемы (как данные, без доменных полей)

Создать и положить в `schemas/` + зарегистрировать в schema registry:

### A) `skeleton_review_questions.schema.json`

Схема описывает UX-вопросы, которые показывает UI.

**Question** универсальный, типы UX:

* `checkbox_group`
* `radio_group`
* `text_input`
* `number_input`
* `multi_text` (несколько полей ввода)
* `matrix_optional` (опционально, если хочешь расширение)

Каждый вопрос должен:

* быть привязан к **одному или нескольким node_id** (чтобы понятно, что меняется),
* иметь `impact` (какие узлы включатся/выключатся/сменят вариант),
* иметь `required` и `priority`.

### B) `skeleton_review_answers.schema.json`

Схема ответов пользователя (универсальная):

* `question_id`
* `value` (string|number|boolean|string[]|object)
* `at`

### C) (если у тебя в skeleton нет status/variant) `contract_skeleton.schema.json` расширить

Добавить в Node опциональные поля:

* `status`: `"active" | "omitted"`
* `variants`: массив вариантов (структурных) для узла
* `selected_variant_id` (если вариант выбран)

Важно: variants здесь **структурные**, не текстовые.

---

## Что нужно реализовать (поведение)

### 1) Генерация review-вопросов: шаг `SKELETON_REVIEW_PLAN` (LLM)

Добавить LLM-шаг, который:

* читает `mission + domain + skeleton_draft + issues`
* возвращает:

  * `review.questions[]` (по схеме),
  * `next_action = ask_user` (UI должен отобразить вопросы)

#### Какие вопросы нужно генерировать (абстрактно)

LLM должна находить “структурные развилки” по сигналам:

* узлы с `include_if` (условные)
* узлы, у которых `requires` указывает на отсутствующие данные (значит либо спросить данные, либо выключить узел)
* группы узлов с похожими tags (можно предложить short/full)
* регуляторные/рисковые темы по tags (можно предложить добавить/убрать блоки)

#### Ограничения

* максимум 7 вопросов за итерацию
* вопросы должны быть конкретными и менять структуру/параметры, а не “расскажите подробнее”
* каждый вопрос должен иметь `ux.type` из списка, чтобы UI знал, как рисовать

---

### 2) UX отображение вопросов

UI должен уметь строить формы автоматически по `review.questions`:

* `checkbox_group` → список чекбоксов
* `radio_group` → радиокнопки
* `text_input` → строка
* `number_input` → число
* `multi_text` → несколько полей (например, 2–5)

Каждый вариант (`option`) должен иметь:

* `label`
* `value`
* `impact` (что изменится при выборе)

---

### 3) Применение ответов: шаг `SKELETON_REVIEW_APPLY`

После того как пользователь отправил ответы:

1. сохранить их в `state.review.answers`
2. применить изменения к skeleton_draft:

   * включить/выключить узлы (status)
   * выбрать вариант (selected_variant_id)
   * добавить/уточнить данные в `state.domain` (только если вопрос был input-типа, и это нужно для структуры)
3. обновить issues:

   * закрыть issues, которые были решены ответами
   * добавить новые, если ответы создают конфликт/неполноту

**Важно:** применение не должно требовать знания доменных ключей в коде. Все изменения идут через patch-операции, сформированные LLM или простым executor’ом по `impact`.

---

## Модель “Impact” (обязательная часть вопроса)

Каждый option в вопросе должен иметь `impact`, описывающий действия:

Поддержать минимальные операции:

* `set_node_status`: { node_id, status: active|omitted }
* `select_variant`: { node_id, variant_id }
* `set_domain_value`: { path, value }  (path = JSON pointer в domain)
* `add_issue` / `resolve_issue` (опционально)

UI не применяет impact сам — он лишь отправляет выбранные значения. Применение делает бек/оркестратор.

---

## Итерации и Freeze

Реализовать правило:

* максимум **2 итерации** review (или 1, если хочешь жёстче)
* после этого:

  * `state.document.skeleton_final = updated skeleton`
  * `state.document.freeze.structure = true`
  * `state.review.status = frozen`
  * `next_action = proceed_to_clause_requirements`

Запрет после freeze:

* любые patches, которые добавляют новые `section/clause` узлы, должны отклоняться policy guard’ом.

---

## LLM Prompts (добавить к заданию обязательно)

### System prompt для `SKELETON_REVIEW_PLAN` (RU)

```
Ты — агент настройки структуры договора.

Ты получаешь mission, state.domain и skeleton_draft (структуру договора без текста).
Твоя задача — сформировать набор UX-вопросов (чекбоксы/радио/ввод), которые помогут пользователю:
— включить/исключить опциональные разделы и пункты,
— выбрать короткий/полный вариант структуры,
— заполнить только те данные, которые необходимы для структуры.

Ограничения:
1) Никаких юридических формулировок договора.
2) Не придумывай факты. Если нужно — спроси через input.
3) Максимум 7 вопросов за итерацию.
4) Каждый вопрос должен быть привязан к node_id(ам) и содержать impact для вариантов.
5) Вопросы должны быть абстрактными и работать для любых договоров.
6) Верни только JSON по schema skeleton_review_questions.
```

### System prompt для `SKELETON_REVIEW_APPLY` (RU) — если хочешь применять через LLM

```
Ты применяешь ответы пользователя к skeleton_draft.
Верни patch, который:
— обновляет status/variants узлов,
— при необходимости добавляет в domain значения из input-вопросов,
— обновляет issues (resolve/add),
— и формирует skeleton_final при завершении review.
Никаких новых узлов после freeze.
Верни только JSON по llm_step_output.
```

---

## Acceptance Criteria (проверка готовности)

1. Система генерирует 3–7 UX-вопросов для любого skeleton_draft.
2. Вопросы отображаются в UI корректно (checkbox/radio/input).
3. Ответы пользователя приводят к изменению skeleton_draft:

   * узлы включаются/выключаются,
   * выбираются варианты,
   * при необходимости пополняется domain (через input).
4. После 1–2 итераций skeleton фиксируется как skeleton_final (freeze=true).
5. После freeze дальнейшие шаги не могут добавлять новые секции/пункты.

---

## Примечание (важно)

Не добавляй логику “какие секции бывают у договора” в код.
Весь смысл — в tags, include_if, requires и в LLM-планировании вопросов.

---
