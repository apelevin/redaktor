# Инструкция для Cursor: Этап “до Skeleton” (LLM-first)

## 0) Цель реализации

Собрать сервисный контур, который в цикле:

1. принимает свободный текст пользователя,
2. обновляет единое состояние кейса (Contract IR Draft),
3. ведёт список issues,
4. генерирует следующий вопрос,
5. и принимает решение “готово к skeleton / нужно уточнять”.

Результат этапа: `state.ready_for_skeleton = true` + причины, или `next_action = ask_user`.

---

## 1) Жёсткие принципы (обязательные)

1. **RU-only / RU-law**: язык и юрисдикция — константа пайплайна; пользователь не выбирает.
2. **Код не знает доменных полей**: никаких `docType`, `paymentTerms` и т.п. в типах/логике. Всё доменное — внутри `state.domain` как произвольный JSON.
3. **Схемы существуют, но как данные**: JSON Schema хранится как версионируемые файлы/записи и подаётся в LLM + используется для валидации.
4. **LLM возвращает patch + next_action**: модель не “переписывает весь state”, а возвращает изменения (patch) и следующий шаг.
5. **Facts vs Assumptions**: модель обязана маркировать, что подтверждено пользователем, а что предположение.

---

## 2) Артефакты проекта, которые нужно создать (как концептуальные сущности)

### 2.1. Contract IR Draft (единое состояние сессии)

Состояние всегда хранит 5 разделов (они фиксированы):

* `meta`: идентификаторы, версии схем, статус, таймстемпы
* `domain`: произвольный JSON (всё про сделку/контракт)
* `issues`: массив объектов issue
* `dialogue`: история сообщений + “какие вопросы уже задавали”
* `control`: счётчики, лимиты, режимы (например max вопросов подряд)

> Важно: `domain` — свободная структура. Остальные разделы — минимально фиксированы для управляемости.

### 2.2. Schema Registry (версии схем)

Нужно 2–3 схемы как “источник истины”:

* `state_schema` — валидирует общий shape state (meta/domain/issues/dialogue/control)
* `llm_output_schema` — валидирует ответ LLM (patch/next_action/rationale)
* `issue_schema` — валидирует issue (severity, missing, status и т.п.)

Схемы должны иметь:

* `schema_id`
* `schema_version`
* `compatibility` (backward compatible / breaking)

### 2.3. LLM Step Output (универсальный контракт ответа модели)

В каждом вызове LLM обязана вернуть:

* `patch` (как изменить state)
* `next_action`:

  * `ask_user`: вопрос + формат ответа (free_text или choices)
  * `proceed_to_gate`: если “кажется готово”
  * `proceed_to_skeleton`: если gate пройден
* `rationale`: короткое объяснение *почему* (для дебага и прозрачности)
* `safety`: флаги (например “есть assumptions, которые надо подтвердить”)

---

## 3) Модули, которые нужно реализовать (по смыслу)

### 3.1. Session Orchestrator

Ответственность:

* принимать вход пользователя,
* доставать текущий state,
* запускать LLM-steps,
* применять patch,
* записывать trace,
* возвращать фронту `next_action`.

Правило: оркестратор не содержит юридической логики.

### 3.2. LLM Step Runner

Ответственность:

* собрать prompt из (state + последнее сообщение + схемы + цель шага),
* вызвать LLM,
* провалидировать JSON по `llm_output_schema`,
* вернуть структурированный результат (или ошибку/повтор с исправлением).

### 3.3. Patch Applier

Ответственность:

* применить patch к state (и ничего больше),
* обеспечить “не перетирать историю”,
* фиксировать версию state (optimistic концепт).

### 3.4. Policy Guard (минимальные правила качества процесса)

Ответственность:

* дедуп вопросов: не задавать по смыслу одно и то же
* не позволять “факты” менять без причины (write-protect подтверждённых фактов)
* лимит циклов: не больше N уточнений подряд без прогресса
* если LLM пытается “придумать” значения — переводить это в assumptions или требовать подтверждение

### 3.5. Gatekeeper (пред-skeleton проверка)

Ответственность:

* запускать отдельный LLM шаг “GATE_CHECK”
* цель: решить `ready_for_skeleton` и перечислить открытые критические issues/assumptions

Gatekeeper не проверяет “все пункты договора”, он проверяет *готовность к структуре*.

---

## 4) Поток работы (как должен идти диалог)

### 4.1. Вход в сессию

* Создай новый state с пустым `domain`, пустыми `issues`.
* `next_action = ask_user` с вопросом “Опишите задачу: какой договор, какая сделка, что важно”.

### 4.2. Каждый пользовательский ответ запускает цикл

1. Записать сообщение в `dialogue.history`.
2. Запустить LLM шаг **INTERPRET**:

   * извлечь факты,
   * обновить `domain` и `slots` (если используешь),
   * обновить `issues`,
   * предложить `next_action`.
3. Прогнать `Policy Guard`.
4. Если `next_action = proceed_to_gate` → запустить **GATE_CHECK**.
5. После gate:

   * если `ready=false` → `ask_user` с самым критичным вопросом
   * если `ready=true` → `proceed_to_skeleton`

---

## 5) Как формируется следующий вопрос (без question bank)

LLM обязана следовать правилу:

* следующий вопрос = закрывает **самый критичный открытый issue**
* вопрос **однозначный**, без “расскажите подробнее обо всём”
* если есть конфликт фактов — вопрос на разрешение конфликта
* если есть assumptions — вопрос на подтверждение assumptions

Формат вопроса должен быть в `next_action.ask_user`:

* `question_text`
* `answer_format`: `free_text` или `choices`
* если `choices` — список вариантов (генерирует LLM)

---

## 6) Что такое Issue (обязательная дисциплина)

Issue — это не “вообще риск”, а управляемый объект:

* `title` (коротко)
* `severity` (critical/high/med/low)
* `why_it_matters` (1 строка)
* `missing_or_conflict` (что не определено или что конфликтует)
* `resolution_hint` (какой вопрос поможет закрыть)
* `status` (open/resolved)

Критично: issues должны быть **дедуплицированы** (по смыслу/ключу).

---

## 7) Разделение “факты vs предположения”

Внутри `domain` заведи соглашение:

* `facts.confirmed` — то, что сказал пользователь
* `facts.unconfirmed` — извлечено из текста, но не подтверждено
* `assumptions` — предположения модели

Политика:

* gate запрещает переход к skeleton, если есть **critical assumptions**.

---

## 8) Готовность к skeleton (что значит “готово”)

Gatekeeper должен давать решение на основе категорий (не полей):

* определены роли сторон (кто кому что обязан)
* определён предмет (что является объектом сделки)
* определена коммерческая модель (деньги/оплата/цена или принцип цены)
* определены сроки/события исполнения (когда и как происходит)
* нет критических конфликтов в фактах
* критические assumptions подтверждены или сняты

Если что-то не выполнено — gate возвращает **конкретный вопрос**, который закрывает ближайшую критичную дыру.

---

## 9) Логи и трассировка (обязательно для дебага)

Каждый ход сохраняй как trace-элемент:

* вход пользователя,
* state до,
* llm_output,
* state после,
* причина next_action.

Это позволит воспроизводить сессии и делать regression tests.

---

## 10) Что НЕ делать на этом этапе

* Не генерировать текст договора и пункты.
* Не пытаться “идеально юридически проверить”.
* Не уходить в реквизиты и подписи раньше, чем есть предмет/деньги/сроки/исполнение (это правило процесса).

---

## 11) Определение Done для этапа V1

Этап считается готовым, если:

* для 10–20 разных миссий система стабильно приходит к `ready_for_skeleton=true`,
* вопросы не повторяются и не уходят в общие рассуждения,
* issues отражают реальные “дыры” и закрываются вопросами,
* все данные хранятся в Contract IR Draft и воспроизводимы.